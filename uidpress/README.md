# uidpress
CoT UID compression testbench

## Background

In the CoT protocol, as used by the TAK application family, each protocol
message contains a mandatory UID attribute, which uniquely identifies the
entity described in the message (NB **not** the message itself)

Specification-wise, the only requirement for the UID attribute is to
"ensure global uniqueness"; it has no standard size, format or content.
As a result, almost every application in the CoT ecosystem appears to have
its own UID format, and this is OK.
See the file uid-test.txt for some examples of real-world CoT UIDs.

## The problem

Many of the UID formats currently in use are unnecessarily large in size
(20 to over 40 bytes), causing performance concerns on low-bandwidth channels
such as long-range radio. Unfortunately, however, due to the UIDs being
randomly generated, they are not easily compressible using conventional
algorithmic methods.

## Proposal

The compression method proposed in this project is based on the knowledge
that UIDs are usually generated by applying a static **format** to
a random, serial, or otherwise unique, **number**.

By using a dictionary of REGEX patterns to detect the format, applying it
*in reverse* to "recover" the original value, and transmitting the format
ID and the number instead of the formatted string, an efficient compression
can be achieved.

### Example:
Consider the native UID: `ANDROID-849182660417201`
HEX representation:
`414e44524f49442d383439313832363630343137323031` (size=23 bytes)

**Encoding**
This is a known UID format, typical to the ATAK app, generated by appending
the sequence `ANDROID-` to the phone's 15-digit IMEI code.
In our dictionary of patterns, this is found at position 3:
`{ 'name': 'and-dec15',   'regex': '^ANDROID-[0-9]{15}$' }`

The compressed representation of the UID will be the format ID, followed by
the IMEI number in big-endian binary form:
`03030453bed2d6b1` (size: 8 bytes)

**Decoding**
The recipient reads the first byte of the compressed data `03`, which
indicates format number 3, then reads the rest of the data `030453bed2d6b1`
as integer number 849182660417201. Finally, it re-generates the original
UID by applying the formatting function `ANDROID-%015d`.

## Implementation

As shown above, compression is a two-step process: first, the best-match
format is chosen and encoded, next, the variable part of the UID is isolated
and encoded, usually using a base conversion to base-256.
For decompression, the first bytes in packet are parsed to select the format,
then the rest of the packet is converted and formatted per format
specifications.

### Format detection and encoding

Two dictionaries are used: PATTERNS and MODIFIERS.

**PATTERNS** are REGEX definitions used for identifying, classifying and
encoding UID formats

**MODIFIERS** are static prefixes and suffixes applied to entity UIDs in
certain situations in order to create derivative UIDs for related, but
distinct events, such as alerts, chat messages etc. They are a separate
category to UID patterns, and are uncorrelated - any modifier can apply
to any primary UID irrespective of the UID pattern

First, the input UID is checked for the presence of a modifier. If one is
found, it is recorded (as a numeric index in the MODIFIERS table), then
stripped to expose the base UID.

Next, the UID is checked for known format patterns. If one is found, it is
recorded as a numeric index in the PATTERNS table (0 = NONE)

The format and modifier IDs are encoded to form the header of the compressed
packet as follows:
- first byte:
  - bit 0-6: pattern ID 0-127 (0=literal)
  - bit 7(MSB), if set, means next byte (modifier ID) is present
- second byte (see above):
  - bit 0-4: modifier ID 0-63 (0=reserved)
  - bit 5-7: RESERVED

### Value isolation and encoding

Once the UID format is known, the value is extracted by stripping all constant
elements of the format and converting the remaining (variable) part to a
single integer or a bit-packed byte sequence.
The actual algorithm for encoding the variable part of the UID depends on the
UID format, but in most cases involves a base conversion to **base256**.

**EXAMPLE**: in the example given above, a **base10** to **base256** conversion
is used. If the format only contains digits and uppercase letters, **base36**
is used instead. A modified version of **base64** is used for UIDs that
contain digits and mixed-case letters, and so on.

See function uid_codec() in the Python code for details.

## Performance

Run against several datasets of real-world UIDs collected from public sources,
the average compression achieved using this method has been constantly better
than 50%, for an average UID size per dataset between 26-34 bytes.

---
Copyright 2021 by https://github.com/a-f-G-U-C, MIT license
